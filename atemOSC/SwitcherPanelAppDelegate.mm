/* -LICENSE-START-
** Copyright (c) 2011 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
** 
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

#import "SwitcherPanelAppDelegate.h"
#include <libkern/OSAtomic.h>
#include <string>
#import "AMSerialPortList.h"
#import "AMSerialPortAdditions.h"

static inline bool	operator== (const REFIID& iid1, const REFIID& iid2)
{
	return CFEqual(&iid1, &iid2);
}

template <class T=IUnknown>
class GenericMonitor : public T
{
public:
    GenericMonitor(SwitcherPanelAppDelegate* uiDelegate) : mUiDelegate(uiDelegate), mRefCount(1) { }
    
protected:
    virtual ~GenericMonitor() { }
    SwitcherPanelAppDelegate*        mUiDelegate;
    
public:
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, LPVOID *ppv)
    {
        if (!ppv)
            return E_POINTER;
        
        if (iid == IID_IBMDSwitcherMixEffectBlockCallback)
        {
            *ppv = static_cast<T*>(this);
            AddRef();
            return S_OK;
        }
        
        if (CFEqual(&iid, IUnknownUUID))
        {
            *ppv = static_cast<T*>(this);
            AddRef();
            return S_OK;
        }
        
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return ::OSAtomicIncrement32(&mRefCount);
    }
    
    ULONG STDMETHODCALLTYPE Release(void)
    {
        int newCount = ::OSAtomicDecrement32(&mRefCount);
        if (newCount == 0)
            delete this;
        return newCount;
    }
    
private:
    int                                mRefCount;
};

// Callback class for monitoring property changes on a mix effect block.
class MixEffectBlockMonitor : public GenericMonitor<IBMDSwitcherMixEffectBlockCallback>
{
public:
    MixEffectBlockMonitor(SwitcherPanelAppDelegate* uiDelegate) : GenericMonitor(uiDelegate) { }
    
protected:
    virtual ~MixEffectBlockMonitor() { }
    
public:
    HRESULT PropertyChanged(BMDSwitcherMixEffectBlockPropertyId propertyId)
    {
        switch (propertyId)
        {
            case bmdSwitcherMixEffectBlockPropertyIdProgramInput:
                [mUiDelegate performSelectorOnMainThread:@selector(updateProgramButtonSelection) withObject:nil waitUntilDone:YES];
                break;
            case bmdSwitcherMixEffectBlockPropertyIdPreviewInput:
                [mUiDelegate performSelectorOnMainThread:@selector(updatePreviewButtonSelection) withObject:nil waitUntilDone:YES];
                break;
            case bmdSwitcherMixEffectBlockPropertyIdInTransition:
                [mUiDelegate performSelectorOnMainThread:@selector(updateInTransitionState) withObject:nil waitUntilDone:YES];
                break;
            case bmdSwitcherMixEffectBlockPropertyIdTransitionPosition:
                [mUiDelegate performSelectorOnMainThread:@selector(updateSliderPosition) withObject:nil waitUntilDone:YES];
                break;
            case bmdSwitcherMixEffectBlockPropertyIdTransitionFramesRemaining:
                [mUiDelegate performSelectorOnMainThread:@selector(updateTransitionFramesTextField) withObject:nil waitUntilDone:YES];
                break;
            case bmdSwitcherMixEffectBlockPropertyIdFadeToBlackFramesRemaining:
                [mUiDelegate performSelectorOnMainThread:@selector(updateFTBFramesTextField) withObject:nil waitUntilDone:YES];
                break;
            default:	// ignore other property changes not used for this sample app
                break;
        }
        return S_OK;
    }
};

class DownstreamKeyerMonitor : public GenericMonitor<IBMDSwitcherDownstreamKeyCallback>
{
public:
    DownstreamKeyerMonitor(SwitcherPanelAppDelegate* uiDelegate) : GenericMonitor(uiDelegate) { }
    
protected:
    virtual ~DownstreamKeyerMonitor() { }
    
public:
    HRESULT Notify (BMDSwitcherDownstreamKeyEventType eventType)
    {
        switch (eventType)
        {
            case bmdSwitcherDownstreamKeyEventTypeTieChanged:
                [mUiDelegate performSelectorOnMainThread:@selector(updateDSKTie) withObject:nil waitUntilDone:YES];
                break;
            case bmdSwitcherDownstreamKeyEventTypeOnAirChanged:
                [mUiDelegate performSelectorOnMainThread:@selector(updateDSKOnAir) withObject:nil waitUntilDone:YES];
                break;
            case bmdSwitcherDownstreamKeyEventTypeIsTransitioningChanged:
                // Might want to do something with this down the road
                break;
            case bmdSwitcherDownstreamKeyEventTypeIsAutoTransitioningChanged:
                // Might want to do something with this down the road
                break;
            default:
                // ignore other property changes not used for this app
                break;
        }
        return S_OK;
    }
};

class TransitionParametersMonitor : public GenericMonitor<IBMDSwitcherTransitionParametersCallback>
{
public:
    TransitionParametersMonitor(SwitcherPanelAppDelegate* uiDelegate) : GenericMonitor(uiDelegate) { }
    
protected:
    virtual ~TransitionParametersMonitor() { }
    
public:
    HRESULT Notify (BMDSwitcherTransitionParametersEventType eventType)
    {
        
        switch (eventType)
        {
            case bmdSwitcherTransitionParametersEventTypeNextTransitionSelectionChanged:
                [mUiDelegate performSelectorOnMainThread:@selector(updateUSKTie) withObject:nil waitUntilDone:YES];
                break;
            case bmdSwitcherTransitionParametersEventTypeTransitionSelectionChanged:
                [mUiDelegate performSelectorOnMainThread:@selector(updateUSKTie) withObject:nil waitUntilDone:YES];
                break;
            default:
                // ignore other property changes not used for this app
                break;
        }
        return S_OK;
    }
};

// Monitor the properties on Switcher Inputs.
// In this sample app we're only interested in changes to the Long Name property to update the PopupButton list
class InputMonitor : public GenericMonitor<IBMDSwitcherInputCallback>
{
public:
    InputMonitor(IBMDSwitcherInput* input, SwitcherPanelAppDelegate* uiDelegate) : mInput(input), GenericMonitor(uiDelegate)
    {
        mInput->AddRef();
        mInput->AddCallback(this);
    }
    
protected:
    ~InputMonitor()
    {
        mInput->RemoveCallback(this);
        mInput->Release();
    }
    
public:
    HRESULT Notify(BMDSwitcherInputEventType eventType)
    {
        switch (eventType)
        {
            case bmdSwitcherInputEventTypeLongNameChanged:
                [mUiDelegate performSelectorOnMainThread:@selector(updatePopupButtonItems) withObject:nil waitUntilDone:YES];
            default:	// ignore other property changes not used for this sample app
                break;
        }
        
        return S_OK;
    }
    IBMDSwitcherInput* input() { return mInput; }
    
private:
    IBMDSwitcherInput*			mInput;
};

// Callback class to monitor switcher disconnection
class SwitcherMonitor : public GenericMonitor<IBMDSwitcherCallback>
{
public:
    SwitcherMonitor(SwitcherPanelAppDelegate* uiDelegate) :	GenericMonitor(uiDelegate) { }
    
protected:
    virtual ~SwitcherMonitor() { }
    
public:
    // Switcher events ignored by this sample app
    HRESULT STDMETHODCALLTYPE	Notify(BMDSwitcherEventType eventType, BMDSwitcherVideoMode coreVideoMode)
    {
        if (eventType == bmdSwitcherEventTypeDisconnected)
        {
            [mUiDelegate performSelectorOnMainThread:@selector(switcherDisconnected) withObject:nil waitUntilDone:YES];
        }
        return S_OK;
    }
};

@implementation SwitcherPanelAppDelegate

@synthesize window;

- (void)applicationDidFinishLaunching:(NSNotification *)aNotification
{
    NSMenu* edit = [[[[NSApplication sharedApplication] mainMenu] itemWithTitle: @"Edit"] submenu];
    if ([[edit itemAtIndex: [edit numberOfItems] - 1] action] == NSSelectorFromString(@"orderFrontCharacterPalette:"))
        [edit removeItemAtIndex: [edit numberOfItems] - 1];
    if ([[edit itemAtIndex: [edit numberOfItems] - 1] action] == NSSelectorFromString(@"startDictation:"))
        [edit removeItemAtIndex: [edit numberOfItems] - 1];
    if ([[edit itemAtIndex: [edit numberOfItems] - 1] isSeparatorItem])
        [edit removeItemAtIndex: [edit numberOfItems] - 1];

	mSwitcherDiscovery = NULL;
	mSwitcher = NULL;
	mMixEffectBlock = NULL;
	mMediaPool = NULL;
    mMacroPool = NULL;
    isConnectedToATEM = NO;
	
	mSwitcherMonitor = new SwitcherMonitor(self);
    mDownstreamKeyerMonitor = new DownstreamKeyerMonitor(self);
    mTransitionParametersMonitor = new TransitionParametersMonitor(self);
	mMixEffectBlockMonitor = new MixEffectBlockMonitor(self);
	
	mMoveSliderDownwards = false;
	mCurrentTransitionReachedHalfway = false;
	
	mSwitcherDiscovery = CreateBMDSwitcherDiscoveryInstance();
	if (! mSwitcherDiscovery) {
		NSBeginAlertSheet(@"Could not create Switcher Discovery Instance.\nATEM Switcher Software may not be installed.\n",
							@"OK", nil, nil, window, self, @selector(sheetDidEndShouldTerminate:returnCode:contextInfo:), NULL, window, @"");
	} else {
        [self switcherDisconnected];		// start with switcher disconnected
    
    
        NSUserDefaults *prefs = [NSUserDefaults standardUserDefaults];
        mAddressTextField.stringValue = [prefs stringForKey:@"atem"];
    
        outgoing.intValue = [prefs integerForKey:@"outgoing"];
        incoming.intValue = [prefs integerForKey:@"incoming"];
        oscdevice.stringValue = [prefs objectForKey:@"oscdevice"];
    
        //	make an osc manager- i'm using a custom in-port to record a bunch of extra conversion for the display, but you can just make a "normal" manager
        manager = [[OSCManager alloc] init];
    
        [self portChanged:self];
    
        /// set up notifications
        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(didAddPorts:) name:AMSerialPortListDidAddPortsNotification object:nil];
        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(didRemovePorts:) name:AMSerialPortListDidRemovePortsNotification object:nil];
	
        /// initialize port list to arm notifications
        [AMSerialPortList sharedPortList];
        [self listDevices];
    }
    
}


- (void)controlTextDidEndEditing:(NSNotification *)aNotification {
    [self portChanged:self];
}

- (void) receivedOSCMessage:(OSCMessage *)m	{
    [self logMessage:[NSString stringWithFormat:@"Received OSC message: %@\tValue: %@", [m address], [m value]]];
    if (isConnectedToATEM) { //Do nothing if not connected
        NSArray *address = [[m address] componentsSeparatedByString:@"/"];
    
        if ([[address objectAtIndex:1] isEqualToString:@"atem"] &&
            ([[address objectAtIndex:2] isEqualToString:@"preview"] || [[address objectAtIndex:2]     isEqualToString:@"program"])) {
        
            [self activateChannel:[[address objectAtIndex:3] intValue] isProgram:[[address objectAtIndex:2] isEqualToString:@"program"]];
        
        } else if ([[address objectAtIndex:1] isEqualToString:@"atem"] &&
                   [[address objectAtIndex:2] isEqualToString:@"transition"] &&
                   [[address objectAtIndex:3] isEqualToString:@"bar"]) {
            if (mMoveSliderDownwards)
                mMixEffectBlock->SetFloat(bmdSwitcherMixEffectBlockPropertyIdTransitionPosition, [[m valueAtIndex:0] floatValue]);
            else
                mMixEffectBlock->SetFloat(bmdSwitcherMixEffectBlockPropertyIdTransitionPosition, 1.0-[[m valueAtIndex:0] floatValue]);
        } else if ([[address objectAtIndex:1] isEqualToString:@"atem"] &&
                   [[address objectAtIndex:2] isEqualToString:@"transition"] &&
                   [[address objectAtIndex:3] isEqualToString:@"cut"]) {
            if ([[m valueAtIndex:0] floatValue]==1.0)  mMixEffectBlock->PerformCut();
        } else if ([[address objectAtIndex:1] isEqualToString:@"atem"] &&
                   [[address objectAtIndex:2] isEqualToString:@"transition"] &&
                   [[address objectAtIndex:3] isEqualToString:@"auto"]) {
            if ([[m valueAtIndex:0] floatValue]==1.0)  mMixEffectBlock->PerformAutoTransition();
        } else if ([[address objectAtIndex:1] isEqualToString:@"atem"] &&
                   [[address objectAtIndex:2] isEqualToString:@"transition"] &&
                   [[address objectAtIndex:3] isEqualToString:@"ftb"]) {
            mMixEffectBlock->PerformFadeToBlack();
        } else if ([[address objectAtIndex:1] isEqualToString:@"atem"] &&
                   [[address objectAtIndex:2] isEqualToString:@"transition"] &&
                   [[address objectAtIndex:3] isEqualToString:@"set-type"]) {
            
            HRESULT result;
            NSString *style = [address objectAtIndex:4];
            REFIID transitionStyleID = IID_IBMDSwitcherTransitionParameters;
            IBMDSwitcherTransitionParameters* mTransitionStyleParameters=NULL;
            result = mMixEffectBlock->QueryInterface(transitionStyleID, (void**)&mTransitionStyleParameters);
            if (SUCCEEDED(result))
            {
                if ([style isEqualToString:@"mix"]){
                    mTransitionStyleParameters->SetNextTransitionStyle(bmdSwitcherTransitionStyleMix);
                }
                if ([style isEqualToString:@"dip"]){
                    mTransitionStyleParameters->SetNextTransitionStyle(bmdSwitcherTransitionStyleDip);
                }
                if ([style isEqualToString:@"wipe"]){
                    mTransitionStyleParameters->SetNextTransitionStyle(bmdSwitcherTransitionStyleWipe);
                }
                if ([style isEqualToString:@"sting"]){
                    mTransitionStyleParameters->SetNextTransitionStyle(bmdSwitcherTransitionStyleStinger);
                }
                if ([style isEqualToString:@"dve"]){
                    mTransitionStyleParameters->SetNextTransitionStyle(bmdSwitcherTransitionStyleDVE);
                }
            }
        } else if ([[address objectAtIndex:1] isEqualToString:@"atem"] &&
                   [[address objectAtIndex:2] isEqualToString:@"nextusk"]) {
            switch ([[address objectAtIndex:3] intValue]) {
                case 0:
                    switcherTransitionParameters->SetNextTransitionSelection(bmdSwitcherTransitionSelectionBackground); break;
                case 1:
                    switcherTransitionParameters->SetNextTransitionSelection(bmdSwitcherTransitionSelectionKey1); break;
                case 2:
                    switcherTransitionParameters->SetNextTransitionSelection(bmdSwitcherTransitionSelectionKey2); break;
                case 3:
                    switcherTransitionParameters->SetNextTransitionSelection(bmdSwitcherTransitionSelectionKey3); break;
                case 4:
                    switcherTransitionParameters->SetNextTransitionSelection(bmdSwitcherTransitionSelectionKey4); break;
                default:
                    break;
            }
        } else if ([[address objectAtIndex:1] isEqualToString:@"atem"] &&
                   [[address objectAtIndex:2] isEqualToString:@"usk"]) {
            int t = [[address objectAtIndex:3] intValue];
        
            if (t<=keyers.size()) {
            
                if ([[m value] floatValue] != 0.0) {
                    std::list<IBMDSwitcherKey*>::iterator iter = keyers.begin();
                    std::advance(iter, t-1);
                    IBMDSwitcherKey * key = *iter;
                    bool onAir;
                    key->GetOnAir(&onAir);
                    key->SetOnAir(!onAir);
                    [self logMessage:[NSString stringWithFormat:@"dsk on %@", m]];
                }
            }
        } else if ([[address objectAtIndex:1] isEqualToString:@"atem"] &&
                   [[address objectAtIndex:2] isEqualToString:@"dsk"]) {
            if ([[address objectAtIndex:3] isEqualToString:@"set-tie"])
            {
                int t = [[address objectAtIndex:4] intValue];
                bool value = [[m value] boolValue];
                
                if (t<=dsk.size()) {
                    
                    std::list<IBMDSwitcherDownstreamKey*>::iterator iter = dsk.begin();
                    std::advance(iter, t-1);
                    IBMDSwitcherDownstreamKey * key = *iter;
                    
                    bool isTransitioning;
                    key->IsTransitioning(&isTransitioning);
                    if (!isTransitioning) key->SetTie(value);
                }
            } else if ([[address objectAtIndex:3] isEqualToString:@"tie"])
            {
                int t = [[address objectAtIndex:4] intValue];
                
                if (t<=dsk.size()) {
                    
                    std::list<IBMDSwitcherDownstreamKey*>::iterator iter = dsk.begin();
                    std::advance(iter, t-1);
                    IBMDSwitcherDownstreamKey * key = *iter;
                    
                    bool isTied;
                    key->GetTie(&isTied);
                    bool isTransitioning;
                    key->IsTransitioning(&isTransitioning);
                    if (!isTransitioning) key->SetTie(!isTied);
                }
            } else if ([[address objectAtIndex:3] isEqualToString:@"toggle"])
            {
                int t = [[address objectAtIndex:4] intValue];
                
                if (t<=dsk.size()) {
                    
                    std::list<IBMDSwitcherDownstreamKey*>::iterator iter = dsk.begin();
                    std::advance(iter, t-1);
                    IBMDSwitcherDownstreamKey * key = *iter;
                    
                    bool isLive;
                    key->GetOnAir(&isLive);
                    bool isTransitioning;
                    key->IsTransitioning(&isTransitioning);
                    if (!isTransitioning) key->SetOnAir(!isLive);
                }
            } else if ([[address objectAtIndex:3] isEqualToString:@"on-air"])
            {
                int t = [[address objectAtIndex:4] intValue];
                bool value = [[m value] boolValue];
                
                if (t<=dsk.size()) {
                    
                    std::list<IBMDSwitcherDownstreamKey*>::iterator iter = dsk.begin();
                    std::advance(iter, t-1);
                    IBMDSwitcherDownstreamKey * key = *iter;
                    
                    bool isTransitioning;
                    key->IsTransitioning(&isTransitioning);
                    if (!isTransitioning) key->SetOnAir(value);
                }
            } else {
                int t = [[address objectAtIndex:3] intValue];
                
                if (t<=dsk.size()) {
                    
                    std::list<IBMDSwitcherDownstreamKey*>::iterator iter = dsk.begin();
                    std::advance(iter, t-1);
                    IBMDSwitcherDownstreamKey * key = *iter;
                    
                    bool isTransitioning;
                    key->IsAutoTransitioning(&isTransitioning);
                    if (!isTransitioning) key->PerformAutoTransition();
                }
            }
        } else if ([[address objectAtIndex:1] isEqualToString:@"atem"] &&
                   [[address objectAtIndex:2] isEqualToString:@"mplayer"]) {
            int mplayer = [[address objectAtIndex:3] intValue];
            NSString *type = [address objectAtIndex:4];
            int requestedValue = [[address objectAtIndex:5] intValue];
            BMDSwitcherMediaPlayerSourceType sourceType;

            // check we have the media pool
            if (! mMediaPool)
            {
                [self logMessage:@"No media pool\n"];
                return;
            }
    
            if (mMediaPlayers.size() < mplayer || mplayer < 0)
            {
                [self logMessage:[NSString stringWithFormat:@"No media player %d", mplayer]];
                return;
            }
            
            if ([type isEqualToString:@"clip"])
            {
                sourceType = bmdSwitcherMediaPlayerSourceTypeClip;
            }
            else if ([type isEqualToString:@"still"])
            {
                sourceType = bmdSwitcherMediaPlayerSourceTypeStill;
            }
            else
            {
                [self logMessage:@"You must specify the Media type 'clip' or 'still'"];
                return;
            }
            // set media player source
            HRESULT result;
            result = mMediaPlayers[mplayer-1]->SetSource(sourceType, requestedValue-1);
            if (FAILED(result))
            {
                [self logMessage:[NSString stringWithFormat:@"Could not set media player %d source\n", mplayer]];
                return;
            }
        }else if ([[address objectAtIndex:1] isEqualToString:@"atem"] &&
                  [[address objectAtIndex:2] isEqualToString:@"supersource"]) {
            [self handleSuperSource:m address:address];
        }else if ([[address objectAtIndex:1] isEqualToString:@"atem"] &&
                  [[address objectAtIndex:2] isEqualToString:@"macros"]) {
            [self handleMacros:m address:address];
        }else if ([[address objectAtIndex:1] isEqualToString:@"atem"] &&
                  [[address objectAtIndex:2] isEqualToString:@"aux"]) {
            int auxToChange = [[address objectAtIndex:3] intValue];
            int source = [[m value] intValue];
            [self handleAuxSource:auxToChange channel:source];
        }
    }
}

- (void) handleAuxSource:(int)auxToChange channel:(int)channel {
    BMDSwitcherInputId inputId = channel;
    mSwitcherInputAuxList[auxToChange-1]->SetInputSource(inputId);
}

- (void) handleMacros:(OSCMessage *)m address:(NSArray*)address {
    if (!mMacroPool || !mMacroControl)
    {
        // No Macro support
        OSCMessage *newMsg = [OSCMessage createWithAddress:[m address]];
        [newMsg addInt:(int)0];
        [outPort sendThisMessage:newMsg];
        return;
    }
    if ([[address objectAtIndex:3] isEqualToString:@"get-max-number"]) {
        uint32_t value = [self getMaxNumberOfMacros];
        
        OSCMessage *newMsg = [OSCMessage createWithAddress:[m address]];
        [newMsg addInt:(int)value];
        [outPort sendThisMessage:newMsg];
    } else if ([[address objectAtIndex:3] isEqualToString:@"stop"]) {
        [self stopRunningMacro];
    } else {
        int macroIndex = [[address objectAtIndex:3] intValue];
        if ([[address objectAtIndex:4] isEqualToString:@"name"]) {
            NSString *value = [self getNameOfMacro:macroIndex];
            OSCMessage *newMsg = [OSCMessage createWithAddress:[m address]];
            [newMsg addString:(NSString *)value];
            [outPort sendThisMessage:newMsg];
        } else if ([[address objectAtIndex:4] isEqualToString:@"description"]) {
            NSString *value = [self getDescriptionOfMacro:macroIndex];
            OSCMessage *newMsg = [OSCMessage createWithAddress:[m address]];
            [newMsg addString:(NSString *)value];
            [outPort sendThisMessage:newMsg];
        } else if ([[address objectAtIndex:4] isEqualToString:@"is-valid"]) {
            int value = 0;
            if ([self isMacroValid:macroIndex])
            {
                value = 1;
            }
            OSCMessage *newMsg = [OSCMessage createWithAddress:[m address]];
            [newMsg addInt:(int)value];
            [outPort sendThisMessage:newMsg];
        } else if ([[address objectAtIndex:4] isEqualToString:@"run"]) {
            int value = 0;
            if ([self isMacroValid:macroIndex])
            {
                // Try to run the valid Macro
                value = [self runMacroAtIndex:macroIndex];
            }
            OSCMessage *newMsg = [OSCMessage createWithAddress:[m address]];
            [newMsg addInt:(int)value];
            [outPort sendThisMessage:newMsg];
        }
    }
}

- (void) handleSuperSource:(OSCMessage *)m address:(NSArray*)address {
    if ([[address objectAtIndex:3] isEqualToString:@"border-enabled"]) {
        bool value = [[address objectAtIndex:4] boolValue];
        mSuperSource->SetBorderEnabled(value);
    } else if ([[address objectAtIndex:3] isEqualToString:@"border-outer"]) {
        float value = [[m value] floatValue];
        mSuperSource->SetBorderWidthOut(value);
    } else if ([[address objectAtIndex:3] isEqualToString:@"border-inner"]) {
        float value = [[m value] floatValue];
        mSuperSource->SetBorderWidthIn(value);
    } else if ([[address objectAtIndex:3] isEqualToString:@"border-hue"]) {
        float value = [[m value] floatValue];
        mSuperSource->SetBorderHue(value);
    } else if ([[address objectAtIndex:3] isEqualToString:@"border-saturations"]) {
        float value = [[m value] floatValue];
        mSuperSource->SetBorderSaturation(value);
    } else if ([[address objectAtIndex:3] isEqualToString:@"border-luminescence"]) {
        float value = [[m value] floatValue];
        mSuperSource->SetBorderLuma(value);
    } else if ([[address objectAtIndex:3] isEqualToString:@"box"]) {
        [self handleSuperSourceBox:m address:address];
    }
}

- (void) handleSuperSourceBox:(OSCMessage *)m address:(NSArray*)address {
    int box = [[address objectAtIndex:4] intValue];
    
    // check we have the super source
    if (!mSuperSource)
    {
        [self logMessage:@"No super source"];
        return;
    }
    
    if (mSuperSourceBoxes.size() < box)
    {
        [self logMessage:[NSString stringWithFormat:@"No super source box %d", box]];
        return;
    }
    
    // convert to value required for arrays
    box = box-1;
    
    if ([[address objectAtIndex:5] isEqualToString:@"enabled"]) {
        bool value = [[m value] boolValue];
        mSuperSourceBoxes[box]->SetEnabled(value);
    } else if ([[address objectAtIndex:5] isEqualToString:@"source"]) {
        int value = [[m value] intValue];
        BMDSwitcherInputId InputId = value;
        mSuperSourceBoxes[box]->SetInputSource(InputId);
    } else if ([[address objectAtIndex:5] isEqualToString:@"x"]) {
        float value = [[m value] floatValue];
        mSuperSourceBoxes[box]->SetPositionX(value);
    } else if ([[address objectAtIndex:5] isEqualToString:@"y"]) {
        float value = [[m value] floatValue];
        mSuperSourceBoxes[box]->SetPositionY(value);
    } else if ([[address objectAtIndex:5] isEqualToString:@"size"]) {
        float value = [[m value] floatValue];
        mSuperSourceBoxes[box]->SetSize(value);
    } else if ([[address objectAtIndex:5] isEqualToString:@"cropped"]) {
        bool value = [[m value] boolValue];
        mSuperSourceBoxes[box]->SetCropped(value);
    } else if ([[address objectAtIndex:5] isEqualToString:@"crop-top"]) {
        float value = [[m value] floatValue];
        mSuperSourceBoxes[box]->SetCropTop(value);
    } else if ([[address objectAtIndex:5] isEqualToString:@"crop-bottom"]) {
        float value = [[m value] floatValue];
        mSuperSourceBoxes[box]->SetCropBottom(value);
    } else if ([[address objectAtIndex:5] isEqualToString:@"crop-left"]) {
        float value = [[m value] floatValue];
        mSuperSourceBoxes[box]->SetCropLeft(value);
    } else if ([[address objectAtIndex:5] isEqualToString:@"crop-right"]) {
        float value = [[m value] floatValue];
        mSuperSourceBoxes[box]->SetCropRight(value);
    } else if ([[address objectAtIndex:5] isEqualToString:@"crop-reset"]) {
        mSuperSourceBoxes[box]->ResetCrop();
    }
}


- (void) activateChannel:(int)channel isProgram:(BOOL)program {
    NSString *strip;

    if (program) {
        strip = @"program";
        [self send:self Channel:channel];
    } else {
        strip = @"preview";
    }
    
    
    for (int i = 0;i<=12;i++) {
        OSCMessage *newMsg = [OSCMessage createWithAddress:[NSString stringWithFormat:@"/atem/%@/%d",strip,i]];
        if (channel==i) {[newMsg addFloat:1.0];} else {[newMsg addFloat:0.0];}
        [outPort sendThisMessage:newMsg];
    }

    BMDSwitcherInputId InputId = channel;
    if (program) {
        @try {
            mMixEffectBlock->SetInt(bmdSwitcherMixEffectBlockPropertyIdProgramInput, InputId);
            
        }
        @catch (NSException *exception) {
            NSAlert *alert = [[NSAlert alloc] init];
            [alert setMessageText:exception.name];
            [alert runModal];
        }

        
    } else {
        @try {
            mMixEffectBlock->SetInt(bmdSwitcherMixEffectBlockPropertyIdPreviewInput, InputId);
        }
        @catch (NSException *exception) {
            NSAlert *alert = [[NSAlert alloc] init];
            [alert setMessageText:exception.name];
            [alert runModal];
        }

        
    }
}

- (IBAction)portChanged:(id)sender {
    
    NSUserDefaults *prefs = [NSUserDefaults standardUserDefaults];
    [prefs setObject:[oscdevice stringValue] forKey:@"oscdevice"];
    [prefs setInteger:[outgoing intValue] forKey:@"outgoing"];
    [prefs setInteger:[incoming intValue] forKey:@"incoming"];    
    [prefs synchronize];
    
    [manager removeInput:inPort];
    [manager removeOutput:outPort];
    
        
    outPort = [manager createNewOutputToAddress:[oscdevice stringValue] atPort:[outgoing intValue] withLabel:@"atemOSC"];
    inPort = [manager createNewInputForPort:[incoming intValue] withLabel:@"atemOSC"];
    
    [manager setDelegate:self];

}

- (IBAction)tallyChanged:(id)sender {
    
    NSUserDefaults *prefs = [NSUserDefaults standardUserDefaults];
    [prefs setObject:[NSString stringWithFormat:@"%ld",(long)[[sender selectedItem] tag]] forKey:[NSString stringWithFormat:@"tally%ld",(long)[sender tag]] ];
}

- (void)applicationWillTerminate:(NSNotification*)aNotification
{
	[self cleanUpConnection];
}

- (BOOL)applicationShouldTerminateAfterLastWindowClosed:(NSApplication*)sender
{
	return YES;
}

- (void)sheetDidEndShouldTerminate:(NSWindow *)sheet returnCode:(NSInteger)returnCode contextInfo:(void *)contextInfo
{
	[NSApp terminate:self];
}

//
// Actions
//


- (IBAction)helpButtonPressed:(id)sender {
    
    if ([sender tag] == 1) {
        
        if ([[tallyA itemArray] count]>0) {
            //set helptext
            [heltTextView setAlignment:NSLeftTextAlignment];
            
            NSMutableAttributedString * helpString = [[NSMutableAttributedString alloc] initWithString:@""];
            int i = 0;
            NSDictionary *infoAttribute = @{NSFontAttributeName: [[NSFontManager sharedFontManager] fontWithFamily:@"Monaco" traits:NSUnboldFontMask|NSUnitalicFontMask weight:5 size:12]};
            NSDictionary *addressAttribute = @{NSFontAttributeName: [[NSFontManager sharedFontManager] fontWithFamily:@"Helvetica" traits:NSBoldFontMask weight:5 size:12]};
            
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"Transitions:\n" attributes:addressAttribute]];
            
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\tT-Bar: " attributes:addressAttribute]];
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"/atem/transition/bar\n" attributes:infoAttribute]];
            
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\tCut: " attributes:addressAttribute]];
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"/atem/transition/cut\n" attributes:infoAttribute]];
            
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\tAuto-Cut: " attributes:addressAttribute]];
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"/atem/transition/auto\n" attributes:infoAttribute]];
            
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\tFade-to-black: " attributes:addressAttribute]];
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"/atem/transition/ftb\n" attributes:infoAttribute]];
            
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\nTransition type:\n" attributes:addressAttribute]];
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\tSet to Mix: " attributes:addressAttribute]];
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"/atem/transition/set-type/mix\n" attributes:infoAttribute]];
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\tSet to Dip: " attributes:addressAttribute]];
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"/atem/transition/set-type/dip\n" attributes:infoAttribute]];
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\tSet to Wipe: " attributes:addressAttribute]];
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"/atem/transition/set-type/wipe\n" attributes:infoAttribute]];
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\tSet to Stinger: " attributes:addressAttribute]];
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"/atem/transition/set-type/sting\n" attributes:infoAttribute]];
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\tSet to DVE: " attributes:addressAttribute]];
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"/atem/transition/set-type/dve\n" attributes:infoAttribute]];
            
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\nUpstream Keyers:\n" attributes:addressAttribute]];
            for (int i = 0; i<keyers.size();i++) {
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"\tOn Air KEY %d toggle: ",i+1] attributes:addressAttribute]];
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"/atem/usk/%d\n",i+1] attributes:infoAttribute]];
            }
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"\tBKGD: "] attributes:addressAttribute]];
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"/atem//0\n"] attributes:infoAttribute]];
            for (int i = 0; i<keyers.size();i++) {
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"\tKEY %d: ",i+1] attributes:addressAttribute]];
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"/atem/nextusk/%d\n",i+1] attributes:infoAttribute]];
            }
            
            
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\nDownstream Keyers:\n" attributes:addressAttribute]];
            for (int i = 0; i<dsk.size();i++) {
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"\tAuto-Transistion DSK%d: ",i+1] attributes:addressAttribute]];
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"/atem/dsk/%d\n",i+1] attributes:infoAttribute]];
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"\tSet DSK On Ait%d: ",i+1] attributes:addressAttribute]];
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"/atem/dsk/on-air/%d\t<0|1>\n",i+1] attributes:infoAttribute]];
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"\tTie Next-Transistion DSK%d: ",i+1] attributes:addressAttribute]];
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"/atem/dsk/tie/%d\n",i+1] attributes:infoAttribute]];
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"\tSet Tie Next-Transistion DSK%d: ",i+1] attributes:addressAttribute]];
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"/atem/dsk/set-tie/%d\t<0|1>\n",i+1] attributes:infoAttribute]];
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"\tToggle DSK%d: ",i+1] attributes:addressAttribute]];
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"/atem/dsk/toggle/%d\n",i+1] attributes:infoAttribute]];
            }

            
            
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\nSources:\n" attributes:addressAttribute]];
            
            for (NSMenuItem *a in [tallyA itemArray]) {
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"\t%@: ",[a title]] attributes:addressAttribute]];
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"/atem/program/%ld\n",(long)[a tag]] attributes:infoAttribute]];
                i++;
            }
            
            
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\nAux Outputs:\n" attributes:addressAttribute]];
            for (int i = 0; i<mSwitcherInputAuxList.size();i++) {
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"\tSet Aux %d to Source: ",i+1] attributes:addressAttribute]];
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"/atem/aux/%d\t<valid_program_source>\n",i+1] attributes:infoAttribute]];
            }
            
            if (mMediaPlayers.size() > 0)
            {
                uint32_t clipCount;
                uint32_t stillCount;
                HRESULT result;
                result = mMediaPool->GetClipCount(&clipCount);
                if (FAILED(result))
                {
                    // the default number of clips
                    clipCount = 2;
                }
                result = mMediaPool->GetStills(&mStills);
                if (FAILED(result))
                {
                    // ATEM TVS only supports 20 stills, the others are 32
                    stillCount = 20;
                }
                else
                {
                    result = mStills->GetCount(&stillCount);
                    if (FAILED(result))
                    {
                        // ATEM TVS only supports 20 stills, the others are 32
                        stillCount = 20;
                    }
                }
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\nMedia Players:\n" attributes:addressAttribute]];
                for (int i = 0; i < mMediaPlayers.size(); i++)
                {
                    for (int j = 0; j < clipCount; j++)
                    {
                        [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"\tSet MP %d to Clip %d: ",i+1,j+1] attributes:  addressAttribute]];
                        [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"/atem/mplayer/%d/clip/%d\n",i+1,j+1] attributes:infoAttribute]];
                    }
                    for (int j = 0; j < stillCount; j++)
                    {
                        [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"\tSet MP %d to Still %d: ",i+1,j+1] attributes:  addressAttribute]];
                        [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"/atem/mplayer/%d/still/%d\n",i+1,j+1] attributes:infoAttribute]];
                    }
                }
            }
            
            
            if (mSuperSourceBoxes.size() > 0)
            {
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\nSuper Source:\n" attributes:addressAttribute]];
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\tValid values specified in <>\n\n" attributes:addressAttribute]];
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\tSet the border enabled flag: " attributes:  addressAttribute]];
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"/atem/supersource/border-enabled\t<0|1>\n" attributes:infoAttribute]];
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\tSet the border outer width: " attributes:  addressAttribute]];
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"/atem/supersource/border-outer\t<float>\n" attributes:infoAttribute]];
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\tSet the border inner width: " attributes:  addressAttribute]];
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"/atem/supersource/border-inner\t<float>\n" attributes:infoAttribute]];
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\tSet the border hue: " attributes:  addressAttribute]];
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"/atem/supersource/border-hue\t<float>\n" attributes:infoAttribute]];
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\tSet the border saturation: " attributes:  addressAttribute]];
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"/atem/supersource/border-saturation\t<float>\n" attributes:infoAttribute]];
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\tSet the border luminescence: " attributes:  addressAttribute]];
                [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"/atem/supersource/border-luminescence\t<float>\n" attributes:infoAttribute]];
                for (int i = 1; i <= mSuperSourceBoxes.size(); i++)
                {
                    [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"\tSet Box %d enabled: ",i] attributes:  addressAttribute]];
                    [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"/atem/supersource/box/%d/enabled\t<0|1>\n",i] attributes:infoAttribute]];
                    [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"\tSet Box %d Input source: ",i] attributes:  addressAttribute]];
                    [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"/atem/supersource/box/%d/source\t<see sources for valid options>\n",i] attributes:infoAttribute]];
                    [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"\tSet Box %d Position X: ",i] attributes:  addressAttribute]];
                    [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"/atem/supersource/box/%d/x\t<float>\n",i] attributes:infoAttribute]];
                    [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"\tSet Box %d Position Y: ",i] attributes:  addressAttribute]];
                    [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"/atem/supersource/box/%d/y\t<float>\n",i] attributes:infoAttribute]];
                    [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"\tSet Box %d Size: ",i] attributes:  addressAttribute]];
                    [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"/atem/supersource/box/%d/size\t<float>\n",i] attributes:infoAttribute]];
                    [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"\tSet Box %d Cropped Enabled: ",i] attributes:  addressAttribute]];
                    [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"/atem/supersource/box/%d/cropped\t<0|1>\n",i] attributes:infoAttribute]];
                    [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"\tSet Box %d Crop Top: ",i] attributes:  addressAttribute]];
                    [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"/atem/supersource/box/%d/crop-top\t<float>\n",i] attributes:infoAttribute]];
                    [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"\tSet Box %d Crop Bottom: ",i] attributes:  addressAttribute]];
                    [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"/atem/supersource/box/%d/crop-bottom\t<float>\n",i] attributes:infoAttribute]];
                    [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"\tSet Box %d Crop Left: ",i] attributes:  addressAttribute]];
                    [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"/atem/supersource/box/%d/crop-left\t<float>\n",i] attributes:infoAttribute]];
                    [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"\tSet Box %d Crop Right: ",i] attributes:  addressAttribute]];
                    [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"/atem/supersource/box/%d/crop-right\t<float>\n",i] attributes:infoAttribute]];
                    [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"\tReset Box %d Crop: ",i] attributes:  addressAttribute]];
                    [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"/atem/supersource/box/%d/crop-reset\t<1>\n",i] attributes:infoAttribute]];
                }
            }
            
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\nMacros:\n" attributes:addressAttribute]];
            
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\tGet the Maximum Number of Macros: " attributes:addressAttribute]];
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"/atem/macros/get-max-number\n" attributes:infoAttribute]];
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\tStop the currently active Macro (if any): " attributes:addressAttribute]];
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"/atem/macros/stop\n" attributes:infoAttribute]];
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\tGet the Name of a Macro: " attributes:addressAttribute]];
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"/atem/macros/<index>/name\n" attributes:infoAttribute]];
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\tGet the Description of a Macro: " attributes:addressAttribute]];
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"/atem/macros/<index>/description\n" attributes:infoAttribute]];
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\tGet whether the Macro at <index> is valid: " attributes:addressAttribute]];
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"/atem/macros/<index>/is-valid\n" attributes:infoAttribute]];
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"\tRun the Macro at <index>: " attributes:addressAttribute]];
            [helpString appendAttributedString:[[NSAttributedString alloc] initWithString:@"/atem/macros/<index>/run\n" attributes:infoAttribute]];
            
            [helpString addAttribute:NSForegroundColorAttributeName value:[NSColor whiteColor] range:NSMakeRange(0,helpString.length)];
            [[heltTextView textStorage] setAttributedString:helpString];
        }
        helpPanel.isVisible = YES;
    } else if ([sender tag]==2) {
        [[NSWorkspace sharedWorkspace] openURL:[NSURL URLWithString:@"https://github.com/danielbuechele/atemOSC/"]];
    }
    
}

- (IBAction)logButtonPressed:(id)sender {
    [logTextView setTextColor:[NSColor whiteColor]];
    logPanel.isVisible = YES;
}

- (IBAction)mAddressTextFieldUpdated:(id)sender {
    //Updated: save state everytime text field changed
    NSString* address = [mAddressTextField stringValue];
    NSUserDefaults *prefs = [NSUserDefaults standardUserDefaults];
    [prefs setObject:address forKey:@"atem"];
    [prefs synchronize];
}



- (void)connectBMD
{
    NSString* address = [mAddressTextField stringValue];
	
	BMDSwitcherConnectToFailure			failReason;

	// Note that ConnectTo() can take several seconds to return, both for success or failure,
	// depending upon hostname resolution and network response times, so it may be best to
	// do this in a separate thread to prevent the main GUI thread blocking.
	HRESULT hr = mSwitcherDiscovery->ConnectTo((CFStringRef)address, &mSwitcher, &failReason);
	if (SUCCEEDED(hr))
	{
		[self switcherConnected];
	}
	else
	{
		NSString* reason;
		switch (failReason)
		{
			case bmdSwitcherConnectToFailureNoResponse:
				reason = @"No response from Switcher";
				break;
			case bmdSwitcherConnectToFailureIncompatibleFirmware:
				reason = @"Switcher has incompatible firmware";
				break;
			case bmdSwitcherConnectToFailureCorruptData:
				reason = @"Corrupt data was received during connection attempt";
				break;
			case bmdSwitcherConnectToFailureStateSync:
				reason = @"State synchronisation failed during connection attempt";
				break;
			case bmdSwitcherConnectToFailureStateSyncTimedOut:
				reason = @"State synchronisation timed out during connection attempt";
				break;
			default:
				reason = @"Connection failed for unknown reason";
		}
        //Delay 2 seconds before everytime connect/reconnect
        //Because the session ID from ATEM switcher will alive not more then 2 seconds
        //After 2 second of idle, the session will be reset then reconnect won't cause error
        double delayInSeconds = 2.0;
        dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * NSEC_PER_SEC);
        dispatch_after(popTime, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0),
                       ^(void){
                           //To run in background thread
                           [self switcherDisconnected];
                       });
		[self logMessage:[NSString stringWithFormat:@"%@", reason]];
	}
}





- (void)switcherConnected
{
	HRESULT result;
	IBMDSwitcherMixEffectBlockIterator* iterator = NULL;
	IBMDSwitcherInputIterator* inputIterator = NULL;
	IBMDSwitcherMediaPlayerIterator* mediaPlayerIterator = NULL;
	IBMDSwitcherSuperSourceBoxIterator* superSourceIterator = NULL;
    isConnectedToATEM = YES;
    
    if ([[NSProcessInfo processInfo] respondsToSelector:@selector(beginActivityWithOptions:reason:)]) {
        self.activity = [[NSProcessInfo processInfo] beginActivityWithOptions:0x00FFFFFF reason:@"receiving OSC messages"];
    }
    
    OSCMessage *newMsg = [OSCMessage createWithAddress:@"/atem/led/green"];
    [newMsg addFloat:1.0];
    [outPort sendThisMessage:newMsg];
    newMsg = [OSCMessage createWithAddress:@"/atem/led/red"];
    [newMsg addFloat:0.0];
    [outPort sendThisMessage:newMsg];
	
	//[mConnectButton setEnabled:NO];			// disable Connect button while connected
    [greenLight setHidden:NO];
    [redLight setHidden:YES];
	
	NSString* productName;
	if (FAILED(mSwitcher->GetProductName((CFStringRef*)&productName)))
	{
		[self logMessage:@"Could not get switcher product name"];
		return;
	}
	
	[mSwitcherNameLabel setStringValue:productName];
	[productName release];
	
	mSwitcher->AddCallback(mSwitcherMonitor);
	
	// Create an InputMonitor for each input so we can catch any changes to input names
	result = mSwitcher->CreateIterator(IID_IBMDSwitcherInputIterator, (void**)&inputIterator);
	if (SUCCEEDED(result))
	{
		IBMDSwitcherInput* input = NULL;
		
		// For every input, install a callback to monitor property changes on the input
		while (S_OK == inputIterator->Next(&input))
		{
			InputMonitor* inputMonitor = new InputMonitor(input, self);
			IBMDSwitcherInputAux* auxObj;
			result = input->QueryInterface(IID_IBMDSwitcherInputAux, (void**)&auxObj);
			if (SUCCEEDED(result))
			{
				BMDSwitcherInputId auxId;
				result = auxObj->GetInputSource(&auxId);
                if (SUCCEEDED(result))
                {
                    mSwitcherInputAuxList.push_back(auxObj);
                }
			}
			BMDSwitcherInputId id;
            		input->GetInputId(&id);
            		NSString* name;
         		   input->GetLongName((CFStringRef*)&name);
         		   if ([name isEqual: @"SuperSource"])
         		   {
         		       input->QueryInterface(IID_IBMDSwitcherInputSuperSource, (void**)&mSuperSource);
         		   }
			input->Release();
            [name release];
			mInputMonitors.push_back(inputMonitor);
		}
		inputIterator->Release();
		inputIterator = NULL;
	}
    
	// Get the mix effect block iterator
	result = mSwitcher->CreateIterator(IID_IBMDSwitcherMixEffectBlockIterator, (void**)&iterator);
	if (FAILED(result))
	{
		[self logMessage:@"Could not create IBMDSwitcherMixEffectBlockIterator iterator"];
		return;
	}
	
	// Use the first Mix Effect Block
	if (S_OK != iterator->Next(&mMixEffectBlock))
	{
		[self logMessage:@"Could not get the first IBMDSwitcherMixEffectBlock"];
		return;
	}
    
    
    //Upstream Keyer
    IBMDSwitcherKeyIterator* keyIterator = NULL;
    result = mMixEffectBlock->CreateIterator(IID_IBMDSwitcherKeyIterator, (void**)&keyIterator);
    IBMDSwitcherKey* key = NULL;
    if (SUCCEEDED(result))
    {
        while (S_OK == keyIterator->Next(&key)) {
            keyers.push_back(key);
        }
    }
    keyIterator->Release();
    keyIterator = NULL;
    
    
    //Downstream Keyer
    IBMDSwitcherDownstreamKeyIterator* dskIterator = NULL;
    result = mSwitcher->CreateIterator(IID_IBMDSwitcherDownstreamKeyIterator, (void**)&dskIterator);
    IBMDSwitcherDownstreamKey* downstreamKey = NULL;
    if (SUCCEEDED(result))
    {
        while (S_OK == dskIterator->Next(&downstreamKey)) {
            dsk.push_back(downstreamKey);
            downstreamKey->AddCallback(mDownstreamKeyerMonitor);
        }
    }
    dskIterator->Release();
    dskIterator = NULL;


    // Media Players
    result = mSwitcher->CreateIterator(IID_IBMDSwitcherMediaPlayerIterator, (void**)&mediaPlayerIterator);
    if (FAILED(result))
    {
        [self logMessage:@"Could not create IBMDSwitcherMediaPlayerIterator iterator"];
        return;
    }
    
	IBMDSwitcherMediaPlayer* mediaPlayer = NULL;
    while (S_OK == mediaPlayerIterator->Next(&mediaPlayer)) {
        mMediaPlayers.push_back(mediaPlayer);
    }
    mediaPlayerIterator->Release();
    mediaPlayerIterator = NULL;
    
    // get media pool
    result = mSwitcher->QueryInterface(IID_IBMDSwitcherMediaPool, (void**)&mMediaPool);
    if (FAILED(result))
    {
        [self logMessage:@"Could not get IBMDSwitcherMediaPool interface"];
        return;
    }
    
    // get macro pool
    result = mSwitcher->QueryInterface(IID_IBMDSwitcherMacroPool, (void**)&mMacroPool);
    if (FAILED(result))
    {
        [self logMessage:@"Could not get IID_IBMDSwitcherMacroPool interface"];
        return;
    }
    
    // get macro controller
    result = mSwitcher->QueryInterface(IID_IBMDSwitcherMacroControl, (void**)&mMacroControl);
    if (FAILED(result))
    {
        [self logMessage:@"Could not get IID_IBMDSwitcherMacroControl interface"];
        return;
    }
    
	// Super source
    if (mSuperSource) {
        result = mSuperSource->CreateIterator(IID_IBMDSwitcherSuperSourceBoxIterator, (void**)&superSourceIterator);
        if (FAILED(result))
        {
            [self logMessage:@"Could not create IBMDSwitcherSuperSourceBoxIterator iterator"];
            return;
        }
        IBMDSwitcherSuperSourceBox* superSourceBox = NULL;
        while (S_OK == superSourceIterator->Next(&superSourceBox)) {
            mSuperSourceBoxes.push_back(superSourceBox);
        }
        superSourceIterator->Release();
        superSourceIterator = NULL;
    }
    
    switcherTransitionParameters = NULL;
    mMixEffectBlock->QueryInterface(IID_IBMDSwitcherTransitionParameters, (void**)&switcherTransitionParameters);
    switcherTransitionParameters->AddCallback(mTransitionParametersMonitor);
    
    
	mMixEffectBlock->AddCallback(mMixEffectBlockMonitor);
	
	[self mixEffectBlockBoxSetEnabled:YES];
	[self updatePopupButtonItems];
	[self updateSliderPosition];
	[self updateTransitionFramesTextField];
	[self updateFTBFramesTextField];
	
finish:
	if (iterator)
		iterator->Release();
}

- (void)switcherDisconnected
{

    isConnectedToATEM = NO;
	if (self.activity) {
        [[NSProcessInfo processInfo] endActivity:self.activity];
    }
    
    self.activity = nil;
    
    OSCMessage *newMsg = [OSCMessage createWithAddress:@"/atem/led/green"];
    [newMsg addFloat:0.0];
    [outPort sendThisMessage:newMsg];
    newMsg = [OSCMessage createWithAddress:@"/atem/led/red"];
    [newMsg addFloat:1.0];
    [outPort sendThisMessage:newMsg];
    
    //[mConnectButton setEnabled:YES];			// enable connect button so user can re-connect
	[mSwitcherNameLabel setStringValue:@""];
    [greenLight setHidden:YES];
    [redLight setHidden:NO];
	
    
    [self mixEffectBlockBoxSetEnabled:NO];
    
    [self cleanUpConnection];

    [self connectBMD];
}

- (void)cleanUpConnection
{
    // cleanup resources created when switcher was connected
    for (std::list<InputMonitor*>::iterator it = mInputMonitors.begin(); it != mInputMonitors.end(); ++it)
    {
        (*it)->Release();
    }
    mInputMonitors.clear();
    
    while (mSwitcherInputAuxList.size())
    {
        mSwitcherInputAuxList.back()->Release();
        mSwitcherInputAuxList.pop_back();
    }
    
    while (mMediaPlayers.size())
    {
        mMediaPlayers.back()->Release();
        mMediaPlayers.pop_back();
    }
    
    if (mStills)
    {
        mStills->Release();
        mStills = NULL;
    }
    
    if (mMediaPool)
    {
        mMediaPool->Release();
        mMediaPool = NULL;
    }
    
    while (mSuperSourceBoxes.size())
    {
        mSuperSourceBoxes.back()->Release();
        mSuperSourceBoxes.pop_back();
    }
    
    while (keyers.size())
    {
        keyers.back()->Release();
        keyers.pop_back();
    }
    
    while (dsk.size())
    {
        dsk.back()->Release();
        dsk.back()->RemoveCallback(mDownstreamKeyerMonitor);
        dsk.pop_back();
    }
    
    if (mMixEffectBlock)
    {
        mMixEffectBlock->RemoveCallback(mMixEffectBlockMonitor);
        mMixEffectBlock->Release();
        mMixEffectBlock = NULL;
    }
    
    // disconnect monitors
    if (mSwitcher)
    {
        mSwitcher->RemoveCallback(mSwitcherMonitor);
        mSwitcher->Release();
        mSwitcher = NULL;
    }
    
    if (switcherTransitionParameters)
    {
        switcherTransitionParameters->RemoveCallback(mTransitionParametersMonitor);
    }
}

- (BOOL)isMacroValid:(uint32_t)index
{
    HRESULT result;
    bool isValid;
    if (mMacroPool) {
        result = mMacroPool->IsValid(index, &isValid);
        switch (result) {
            case S_OK:
                return isValid;
            case E_INVALIDARG:
                [self logMessage:[NSString stringWithFormat:@"Could not check whether the Macro at index %d is valid because the index is invalid.", index]];
                break;
            default:
                [self logMessage:[NSString stringWithFormat:@"Could not check whether the Macro at index %d is valid.", index]];
                break;
        }
        return NO;
    }
    return NO;
}

- (BOOL)runMacroAtIndex:(uint32_t)index
{
    HRESULT result;
    bool isValid;
    if (mMacroControl) {
        if (![self isMacroValid:index])
        {
            [self logMessage:[NSString stringWithFormat:@"Could not run the Macro at index %d because it is not valid.", index]];
            return NO;
        }
        
        result = mMacroControl->Run(index);
        switch (result) {
            case S_OK:
                return isValid;
            case E_INVALIDARG:
                [self logMessage:[NSString stringWithFormat:@"Could not run the Macro at index %d because the index is invalid.", index]];
                break;
            case E_FAIL:
                [self logMessage:[NSString stringWithFormat:@"Could not run the Macro at index %d.", index]];
                break;
            default:
                [self logMessage:[NSString stringWithFormat:@"Could not run the Macro at index %d.", index]];
                break;
        }
        return NO;
    }
    return NO;
}

- (BOOL)stopRunningMacro
{
    HRESULT result;
    if (mMacroControl) {
        result = mMacroControl->StopRunning();
        switch (result) {
            case S_OK:
                return YES;
            default:
                [self logMessage:@"Could not stop the current Macro."];
                break;
        }
        return NO;
    }
    return NO;
}

- (uint32_t)getMaxNumberOfMacros
{
    uint32_t maxNumberOfMacros = 0;
    if (mMacroPool)
    {
        if (S_OK == mMacroPool->GetMaxCount(&maxNumberOfMacros)) {
            return maxNumberOfMacros;
        } else {
            [self logMessage:@"Could not get max the number of Macros available."];
        }
    }
    return maxNumberOfMacros;
}

- (NSString*)getNameOfMacro:(uint32_t)index
{
    HRESULT result;
    NSString *name = @"";
    result = mMacroPool->GetName(index, (CFStringRef*)&name);
    switch (result)
    {
        case S_OK:
            return name;
        case E_INVALIDARG:
            [self logMessage:[NSString stringWithFormat:@"Could not get the name of the Macro at index %d because the index is invalid.", index]];
            break;
        case E_OUTOFMEMORY:
            [self logMessage:[NSString stringWithFormat:@"Insufficient memory to get the name of the Macro at index %d.", index]];
            break;
        default:
            [self logMessage:[NSString stringWithFormat:@"Could not get the name of the Macro at index %d.", index]];
    }
    return name;
}

- (NSString*)getDescriptionOfMacro:(uint32_t)index
{
    HRESULT result;
    NSString *description = @"";
    result = mMacroPool->GetDescription(index, (CFStringRef*)&description);
    switch (result)
    {
        case S_OK:
            return description;
        case E_INVALIDARG:
            [self logMessage:[NSString stringWithFormat:@"Could not get the description of the Macro at index %d because the index is invalid.", index]];
            break;
        case E_OUTOFMEMORY:
            [self logMessage:[NSString stringWithFormat:@"Insufficient memory to get the description of the Macro at index %d.", index]];
            break;
        default:
            [self logMessage:[NSString stringWithFormat:@"Could not get the description of the Macro at index %d.", index]];
    }
    return description;
}

- (void)logMessage:(NSString *)message
{
    if (message) {
        [self appendMessage:message];
        NSLog(@"%@", message);
    }
}

- (void)appendMessage:(NSString *)message
{
    NSDate *now = [NSDate date];
    NSDateFormatter *formatter = nil;
    formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
    
    NSString *messageWithNewLine = [NSString stringWithFormat:@"[%@] %@\n", [formatter stringFromDate:now], message];
    [formatter release];
    
    // Append string to textview
    [logTextView.textStorage appendAttributedString:[[NSAttributedString alloc]initWithString:messageWithNewLine]];
    
    [logTextView scrollRangeToVisible: NSMakeRange(logTextView.string.length, 0)];
    
    [logTextView setTextColor:[NSColor whiteColor]];
}

//
// GUI updates
//
- (void)updatePopupButtonItems
{
	HRESULT result;
	IBMDSwitcherInputIterator* inputIterator = NULL;
	IBMDSwitcherInput* input = NULL;
	
	result = mSwitcher->CreateIterator(IID_IBMDSwitcherInputIterator, (void**)&inputIterator);
	if (FAILED(result))
	{
        [self logMessage:@"Could not create IBMDSwitcherInputIterator iterator"];
		return;
	}
	


	while (S_OK == inputIterator->Next(&input))
	{
		NSString* name;
		BMDSwitcherInputId id;
        
        
        
		input->GetInputId(&id);
		input->GetLongName((CFStringRef*)&name);
		
        [tallyA addItemWithTitle:name];
		[[tallyA lastItem] setTag:id];
        
        [tallyB addItemWithTitle:name];
		[[tallyB lastItem] setTag:id];
        
        [tallyC addItemWithTitle:name];
		[[tallyC lastItem] setTag:id];
        
        [tallyD addItemWithTitle:name];
		[[tallyD lastItem] setTag:id];
        
		
		input->Release();
		[name release];
	}
	inputIterator->Release();
    
    NSUserDefaults *prefs = [NSUserDefaults standardUserDefaults];
    
    [tallyA selectItemAtIndex:[[prefs objectForKey:@"tally0"] intValue]];
    [tallyB selectItemAtIndex:[[prefs objectForKey:@"tally1"] intValue]];
    [tallyC selectItemAtIndex:[[prefs objectForKey:@"tally2"] intValue]];
    [tallyD selectItemAtIndex:[[prefs objectForKey:@"tally3"] intValue]];
    
    
    
    
	[self updateProgramButtonSelection];
	[self updatePreviewButtonSelection];
}

- (void)updateProgramButtonSelection
{
    
    
	BMDSwitcherInputId	programId;
	mMixEffectBlock->GetInt(bmdSwitcherMixEffectBlockPropertyIdProgramInput, &programId);

    
    [self activateChannel:programId isProgram:YES];
}

- (void)updatePreviewButtonSelection
{
	BMDSwitcherInputId	previewId;
	mMixEffectBlock->GetInt(bmdSwitcherMixEffectBlockPropertyIdPreviewInput, &previewId);

    
    [self activateChannel:previewId isProgram:NO];
}

// Send OSC messages out when DSK Tie is changed on switcher
- (void)updateDSKTie
{
    int i = 1;
    for(std::list<IBMDSwitcherDownstreamKey*>::iterator iter = dsk.begin(); iter != dsk.end(); iter++) {
        IBMDSwitcherDownstreamKey * key = *iter;
        bool isTied;
        key->GetTie(&isTied);
        
        OSCMessage *newMsg = [OSCMessage createWithAddress:[NSString stringWithFormat:@"/atem/dsk/set-tie/%d",i++]];
        [newMsg addInt: isTied];
        [outPort sendThisMessage:newMsg];
    }
}

// Send OSC messages out when DSK On Air is changed on switcher
- (void)updateDSKOnAir
{
    int i = 1;
    for(std::list<IBMDSwitcherDownstreamKey*>::iterator iter = dsk.begin(); iter != dsk.end(); i++, iter++) {
        IBMDSwitcherDownstreamKey * key = *iter;
        bool isOnAir;
        key->GetOnAir(&isOnAir);
        
        OSCMessage *newMsg = [OSCMessage createWithAddress:[NSString stringWithFormat:@"/atem/dsk/on-air/%d",i]];
        [newMsg addInt: isOnAir];
        [outPort sendThisMessage:newMsg];
    }
}

// Send OSC messages out when USK Tie is changed on switcher
- (void)updateUSKTie
{
    uint32_t transitionSelections[5] = { bmdSwitcherTransitionSelectionBackground, bmdSwitcherTransitionSelectionKey1, bmdSwitcherTransitionSelectionKey2, bmdSwitcherTransitionSelectionKey3, bmdSwitcherTransitionSelectionKey4 };
    
    uint32_t currentTransitionSelection;
    switcherTransitionParameters->GetNextTransitionSelection(&currentTransitionSelection);
    
    for (int i = 0; i <= ((int) keyers.size()); i++) {
        uint32_t requestedTransitionSelection = transitionSelections[i];
        
        OSCMessage *newMsg = [OSCMessage createWithAddress:[NSString stringWithFormat:@"/atem/nextusk/%d",i]];
        [newMsg addInt: ((requestedTransitionSelection & currentTransitionSelection) == requestedTransitionSelection)];
        [outPort sendThisMessage:newMsg];
    }
}

- (void)updateInTransitionState
{
	bool inTransition;
	mMixEffectBlock->GetFlag(bmdSwitcherMixEffectBlockPropertyIdInTransition, &inTransition);
	
	if (inTransition == false)
	{
		// Toggle the starting orientation of slider handle if a transition has passed through halfway
		if (mCurrentTransitionReachedHalfway)
		{
			mMoveSliderDownwards = ! mMoveSliderDownwards;
			[self updateSliderPosition];
		}
		
		mCurrentTransitionReachedHalfway = false;
	}
}

- (void)updateSliderPosition
{
	double position;
	mMixEffectBlock->GetFloat(bmdSwitcherMixEffectBlockPropertyIdTransitionPosition, &position);
	
	// Record when transition passes halfway so we can flip orientation of slider handle at the end of transition
	mCurrentTransitionReachedHalfway = (position >= 0.50);

	double sliderPosition = position * 100;
	if (mMoveSliderDownwards)
		sliderPosition = 100 - position * 100;		// slider handle moving in opposite direction
	

    
    OSCMessage *newMsg = [OSCMessage createWithAddress:@"/atem/transition/bar"];
    [newMsg addFloat:1.0-sliderPosition/100];
    [outPort sendThisMessage:newMsg];
}

- (void)updateTransitionFramesTextField
{
	int64_t framesRemaining;
	mMixEffectBlock->GetInt(bmdSwitcherMixEffectBlockPropertyIdTransitionFramesRemaining, &framesRemaining);

}

- (void)updateFTBFramesTextField
{
	int64_t framesRemaining;
	mMixEffectBlock->GetInt(bmdSwitcherMixEffectBlockPropertyIdFadeToBlackFramesRemaining, &framesRemaining);

}

- (void)mixEffectBlockBoxSetEnabled:(bool)enabled
{


}







# pragma mark Serial Port Stuff

- (IBAction)initPort:(id)sender {
    
    
    NSString *deviceName = [serialSelectMenu titleOfSelectedItem];

    if (![deviceName isEqualToString:[port bsdPath]]) {
        
        
        [port close];
        
        [self setPort:[[[AMSerialPort alloc] init:deviceName withName:deviceName type:(NSString*)CFSTR(kIOSerialBSDModemType)] autorelease]];
        [port setDelegate:self];
        
        if ([port open]) {

            [self logMessage:@"successfully connected"];
            
            [connectButton setEnabled:NO];
            [serialSelectMenu setEnabled:NO];
            [tallyGreenLight setHidden:NO];
            [tallyRedLight setHidden:YES];
            
            [port setSpeed:B9600]; 
            
            
            // listen for data in a separate thread
            [port readDataInBackground];
            
            
        } else { // an error occured while creating port
            
            [self logMessage:@"error connecting"];
            //[serialScreenMessage setStringValue:@"Error Trying to Connect..."];
            [self setPort:nil];
            
        }
    }
}




- (void)serialPortReadData:(NSDictionary *)dataDictionary
{
    
    AMSerialPort *sendPort = [dataDictionary objectForKey:@"serialPort"];
    NSData *data = [dataDictionary objectForKey:@"data"];
    
    if ([data length] > 0) {
        
        NSString *receivedText = [[NSString alloc] initWithData:data encoding:NSASCIIStringEncoding];
        [self logMessage:[NSString stringWithFormat:@"Serial Port Data Received: %@",receivedText]];
        
        
        //Typically, I arrange my serial messages coming from the Arduino in chunks, with the
        //data being separated by a comma or semicolon. If you're doing something similar, a 
        //variant of the following command is invaluable. 
        
        //NSArray *dataArray = [receivedText componentsSeparatedByString:@","];
        
        
        // continue listening
        [sendPort readDataInBackground];
        
    } else { 
        // port closed
        [self logMessage:@"Port was closed on a readData operation...not good!"];
        [connectButton setEnabled:YES];
        [serialSelectMenu setEnabled:YES];
        [tallyGreenLight setHidden:YES];
        [tallyRedLight setHidden:NO];
    }
    
}

- (void)listDevices
{
     //get an port enumerator
    NSEnumerator *enumerator = [AMSerialPortList portEnumerator];
    AMSerialPort *aPort;
    [serialSelectMenu removeAllItems];
    
    while (aPort = [enumerator nextObject]) {
        [serialSelectMenu addItemWithTitle:[aPort bsdPath]];
    }
}

- (IBAction)send:(id)sender Channel:(int)channel {


    if([port isOpen]) {
        if (channel>0 && channel<7) {
            
            if (channel == [[tallyA selectedItem] tag]) {[self logMessage:@"A"];[port writeString:@"A" usingEncoding:NSUTF8StringEncoding error:NULL];}
            else if (channel == [[tallyB selectedItem] tag]) {[self logMessage:@"B"];[port writeString:@"B" usingEncoding:NSUTF8StringEncoding error:NULL];}
            else if (channel == [[tallyC selectedItem] tag]) {[self logMessage:@"C"];[port writeString:@"C" usingEncoding:NSUTF8StringEncoding error:NULL];}
            else if (channel == [[tallyD selectedItem] tag]) {[self logMessage:@"D"];[port writeString:@"D" usingEncoding:NSUTF8StringEncoding error:NULL];}
            else {[port writeString:@"0" usingEncoding:NSUTF8StringEncoding error:NULL];};

        } else {
            [port writeString:@"0" usingEncoding:NSUTF8StringEncoding error:NULL];
        }
    }
}

- (AMSerialPort *)port
{
    return port;
}

- (void)setPort:(AMSerialPort *)newPort
{
    id old = nil;
    
    if (newPort != port) {
        old = port;
        port = [newPort retain];
        [old release];
    }
}


# pragma mark Notifications

- (void)didAddPorts:(NSNotification *)theNotification
{
    [self logMessage:@"A port was added"];
    [self listDevices];
}

- (void)didRemovePorts:(NSNotification *)theNotification
{
    [self logMessage:@"A port was removed"];
    [self listDevices];
}




@end
